DHT version control system:


Requirements:
1.Documents('values') should not be able to be altered (by anyone) after storage in the DHT.
2.Saving an edited version of the document should store a patch in the DHT.
3.Finding out if there are newer versions of a document should be possible.
4.Only the original creator should be able to see if there are newer versions of a document.
5.Possibility of creating multiple sub-versions ('branches') of a document should be possible.



To satisfy 1., documents are saved as key->value pairs, where the key is calculated as `hash(value)`. (hash is a one-way hashing function).

To satisfy 2., all versions of a document are saved together with some metadata. Only v0 contain the whole document. v1 contains a patch (e.g. created with the Unix `diff` utility) that might be able to re-create this newer version of the document, and the key of the previous version of the document. v2 links back to v1 in the same way, etc.
	These newer versions are again saved under hash(v1), hash(v2), etc. Including the metadata. This means that we have the property of a Merkle tree: Verification of newer versions ensures that all previous versions including the original document are correct, and thus the resulting document (that can be made by re-applying the patches) will be correct.

To satisfy 3., A second key->value pair called the `pointer_name` is stored per document version. For v0 of the document (lets call it pn0) , this is generated using hash(key(v0)+salt) or in other words, hash(hash(value)+salt). `salt` should be a unique ID generated by the original user (so when two people store the same document, they might refer to it with unique pointer_names). The value of this field is key(v0), e.g. the location where the document can be found.
	For v1, a second pointer_name pn1 is stored with as key hash(key(pn0)+salt) or in other words: hash(hash(key(v0)+salt)+salt). The value here is key(v1).
	For v2, a pointer_name named pn2 is stored with as key hash(key(pn1)) ; in other words:  hash(hash(hash(key(v0)+salt)+salt)+salt)
		Adding the salt at each hash-step ensures that only the original creator (or anyone that knows both the starting hash of v0 and the salt) can move forward in time over the document versions, satisfying 4.

To satisfy 5., whenever someone wishes to create a branch, he can create a new salt and use, for pnX, the key: hash(key(pn(X-1))+newsalt). In other words, up to the point of pn(X-1) the original salt is used, and afterwards, the new salt for the new branch is used.

Note that this ensures that non-default branches can only be detected if:
	-a) a person knows that they exist and at what place to use them.
	-b) these newsalts follow a certain pattern (e.g. incrementing a nonce at the end of the salt), that can be detected by simply testing if the key hash(pn(X-1)+(salt_with_incremented_nonce)) exists.

Problems:
-Possibility of uploading versions of the same document at different locations at the same time (different nodes receive different versions of the document first); pnX then might point at different resources depending on what node you ask.
Best solution:
	?? pointer_name re-ordering? If a second pointer_name is submitted to a node but one with that key (e.g. hash) is already present in its database, automatically create a branch from pnX (with the new salt being 'original_salt+"CONFLICT"'). As it can be different per-node in which order these values are stored, implementations cannot assume one version is correct and the other is not.


Newer solution after reading StackExchange and thinking about Diffie-Hellman-Shared-Encryption:
	-Do not expect that the same document always exists at the same hash across multiple servers. At submit time, this might go wrong.
		-> If a server already has a value for that key, submit it at hash(current_key+n) for increasing n.
	-Do expect that the same document is somewhere within the hash(current_key+n) range of key-value pairs.
		-> So, given a `current_key`, we can obtain a non-ordered array of possibilities from the DHT.
	-Anyone can upload something to any key. Being able to upload proper data to a certain location thus can be done by anyone knowing the current_key.
	-However, the actual saved values should be asynchroniously encrypted. When obtaining a list of child values, clients can drop any values they cannot decrypt. This ensures that 'inserting garbage' by untrusted peers does not disrupt workflow.

	Thus:
		1. is satisfied by a signature inside the value, and the fact that values in the hash(current_key+n) space are not ordered.

Modus Operandi:

-Alice creates a new document, d0 and stores it in the DHT.
-Alice obtains (pointer_name,salt) from the storing implementation, that can be used for later reference.
-Alice shares pointer_name with Bob. 
	As Bob does not have the salt, Bob can not continue Alice's work in the same branch(es). Bob is able to create his own branches by creating his own salt, however. Alice is unable to see these new branches unless Bob gives this salt back to Alice.
-Alice gives both pointer_name and salt to Charlie. Charlie is able to make new versions in Alice's branches, and can also create new branches that Alice can see by incrementing the salt's nonce, in the same way Alice can. Alice and Charlie can both see all of this work.
-If Alice and Charlie attempt to upload something at the exact same moment, their work is split into two branches. However, as some nodes might have located these branches the other way around, Alice or Charlie should create a new proper branch (so that one of the versions continues as branch and the other as new version on the current branch). The algorithm does not depend on this, but it makes the resulting calculations faster as nodes then have the same tree structure again.





Information can thus be stored in a special kind of tree; a 'shuffled-branch' tree.

The 'root node' is in essence the root secret. This value itself should not be stored in the database for security reasons. Instead, one or multiple child nodes, computed with hash(root_secret+n) (where n = 0,1,2...) can be saved.
When wanting to save a newer version of already existing data, one takes the key of the current version as new `root_secret`. Therefore, if we want to create a new version of whatever is under `hash(root_secret+12)`, we would apply `hash(hash(root_secret+12)+0)`. This procedure is exactly the same, and the contents of the inner hash value do not need to be known:
	-Creating a new version or variant happens in constant-time.
	-To add a child to a node (adding a new version), only the key of this node, the to-be parent, is needed.
	-To add a sibling to a node (adding a new variant), the key of its parent node is needed.

note that, `hash(key)` and `hash(hash(key))` (etc) without nonces are NOT used. This is for consistency.


From bottom to top of the protocol layers:
-The Distributed Hash Table. Kademlia, or something else. 
	Anything that maps keys(Unicode strings of varying lengths) to values (Unicode strings of varying lengths).
	(Key,Value) pairs need to be able to be stored, and after storage, given a Key, the Value should be looked up and returned.

-The Shuffled-Branch Tree.
	given a key, look up values in the DHT in the locations:
		-hash(key+n) 	(All siblings at level 1 (one layer below 'key'). Increment n until the DHT returns null)
		-hash(hash(key+n)) (Children of each of these siblings. To obtain their children, repeat recursively: `hash(hash(key+n)+n)`  ))


-The Async Encryption Layer
	The values stored in the Shuffled-Branch Tree are encrypted using an Asynchronious Encryption scheme. Clients are permitted(expected) to only interpret values from the SB-Tree that they can decrypt.

-The Application Layer
	This could be anything that can make use out of a distributed system containing a (shared)private tree of values, with in-band notification of new values.
	Ideas:
		-A distributed Version Control System like Git.
		-A distributed messaging application or bulletin board. Give two (or more) users access to the same (sub)key, and they can read and write each other any number of message-threads (Messages could be nested reddit-style, with any message having any number of replies, each being a message that can again have any number of replies, etc).

TODO:
	-Solving the Race Condition. As the DHT layer does not know `key` when storing hash(key+n), it is impossible to move sideways and store siblings at the next position.
	Solutions:
		-Swapping how to make siblings and how to make children (siblings then are hash(hash(key+n)) while children are hash(key+(n+1) ) ) Drawback: Everyone can make siblings, only can make children when knowing key.